package operator;

// 단락 회로 평가 실습하기
// 논리 연산에서 모든 항이 실행되지 않는 경우 - 단락 회로 평가
public class OperationEx3 {
    public static void main(String[] args) {
        int num1 = 10;
        int i = 2;

        // AND 연산자(&&)의 단락 회로 평가
        // 조건: 두 조건이 모두 true 여야 전체가 true
        //                 20  =  10  + 10        &&
        boolean value = ((num1 = num1 + 10) < 10) && ((i = i + 2) < 10);
        System.out.println("\nvalue : " + value); // false 출력
        System.out.println("num1 : " + num1);     // 20 출력 (변경됨)
        System.out.println("i : " + i);           // 2 출력 (변경되지 않음!)

        //         30  =  20  + 10
        value = ((num1 = num1 + 10) > 10) || ((i = i + 2) < 10);
        System.out.println("\nvalue : " + value); // true 출력
        System.out.println("num1 : " + num1);     // 30 출력 (또 다시 변경됨)
        System.out.println("i : " + i);           // 2 출력 (여전히 변경되지 않음!)

        /*
           [AND 연산자(&&) 실행 순서]
           1. (num1 = num1 + 10): 10 + 10 = 20, num1에 20 저장
           2. 20 < 10: false 반환
           3. && 연산자: 첫 번째가 'false; 이므로 두 번째 조건은 확인하지 않음 (단락 회로!)
           4. (i = i + 2) < 10: 이 부분은 실행되지 않음 (i는 여전히 2)
           5. 최종 결과: false
         */

        /*
         * 핵심 포인트:
         - num1은 두 번 모두 변경됨 (10 → 20 → 30)
         - i는 두 번 모두 변경되지 않음 (계속 2)
         - 이것이 바로 단락 회로 평가의 특징!

         * 실무 활용 예시:
         - if (object != null && object.method() > 0)
           → null 체크를 먼저 하여 NullPointerException 방지

         * 주의사항:
         - 조건식에 부작용이 있는 연산을 넣을 때는 신중해야 함
         - 단락 회로로 인해 예상과 다른 결과가 나올 수 있음
         */


        /*
            boolean value = ((num1 = num1 + 10) < 10) && ((i = i + 2) < 10);
            'AND 연산' : 두 개의 조건을 모두 확인 해야 하는 상황에서
            첫 번째 조건이 이미 거짓이라면 --> 두 번째 조건은 확인할 필요가 없음
            프로그램이 지름길을 찾아서 불필요한 계산을 생략하는 것

            'OR 연산' : 첫 번째 조건이 이미 참이라면  --> 두 번째 조건을 확인하지 않고
            바로 "참"이라는 결과를 내놓음

            ---------------------------------------------------------------------------------
            ✓ 왜 이런 최적화가 생겼을까?
            - 초기 컴퓨터들은 지금처럼 빠르지 않음
            - 메모리도 부족하고 처리속도도 느림
            - 프로그래머들은 조금이라도 계산을 줄일 수 있는 방법을 찾아야 했음

            • 성능 향상 : 불필요한 계산을 생략해서 프로그램이 더 빨라짐
            • 안전성 확보 : 위험한 연산 피할 수 있음
              --> ex) 배열이 존재하는지 확인 후 배열의 크기 확인
             • 자원 절약 : CPU 와 메모리를 더 효율적으로 사용


         */
    }
}
